{"date": "2026-02-14", "id": 56, "title": "Merge Intervals", "difficulty": "medium", "topics": ["sorting", "intervals"], "status": "solved", "time_min": 7, "result": "AC", "approach": "Sort intervals then merge into result by extending overlapping end points.", "key_insight": "Sorting by start ensures overlaps appear consecutively so you only compare with the last merged interval.", "mistakes": null, "complexity": "O(n log n) time for sorting, O(1) extra space."}
{"date":"2026-02-14","id":567,"title":"Permutation in String","difficulty":"medium","topics":["sliding-window","frequency-count"],"status":"solved","time_min":22,"result":"AC","approach":"Maintain fixed-length sliding window with char counts; decrement on entering, increment when leaving, track missing chars.","key_insight":"Keep window size equal to |s1| so when missing==0 you have a permutation.","mistakes":"Needed hint to enforce fixed window size; took 3 submissions.","complexity":"O(n) time, O(1) space (26 letters).","notes_path":null}
{"date":"2026-02-15","id":3,"title":"Longest Substring Without Repeating Characters","difficulty":"medium","topics":["sliding-window","hashing"],"status":"solved","time_min":15,"result":"AC","approach":"Use visited array for ASCII chars and move left pointer past duplicates while tracking max window length.","key_insight":"Shrink window only when duplicate reappears; keep window unique via visited flags.","mistakes":"Needed reminder to increment left appropriately when duplicate hit.","complexity":"O(n) time, O(1) space (fixed alphabet).","notes_path":null}
{"date":"2026-02-15","id":560,"title":"Subarray Sum Equals K","difficulty":"medium","topics":["prefix-sum","hashmap"],"status":"solved","time_min":18,"result":"AC","approach":"Track running prefix sum and count how many previous prefixes equal prefix-k; add those counts to result each step.","key_insight":"Prefix differences stay valid even with negatives, unlike sliding windows; seeding map with 0 handles subarrays starting at index 0.","mistakes":"Tried sliding window first and realized it fails when negatives appear.","complexity":"O(n) time, O(n) space for hash map.","notes_path":null}
{"date":"2026-02-15","id":438,"title":"Find All Anagrams in a String","difficulty":"medium","topics":["sliding-window","frequency-count"],"status":"solved","time_min":7,"result":"AC","approach":"Maintain fixed-length sliding window with freq array; decrement when char enters, increment when it leaves, and track missing count.","key_insight":"Keep window size equal to |p| so once missing hits zero you record the left index.","mistakes":null,"complexity":"O(n) time, O(1) space (26 letters).","notes_path":null}
{"date":"2026-02-16","id":76,"title":"Minimum Window Substring","difficulty":"hard","topics":["sliding-window","two-pointers","string"],"status":"review","time_min":20,"result":"AC","hints":1,"approach":"Maintain freq deficits for T; expand right and decrement missing until zero, then shrink left while window still valid, tracking best span.","key_insight":"Left pointer can keep moving while removing surplus chars (freq becomes <=0); stop only when removing makes freq>0 meaning window loses required char.","mistakes":"Uncertain about when to stop shrinking left; needed reminder that freq>0 indicates deficit.","complexity":"O(n) time, O(1) space (fixed alphabet)."}
{"date":"2026-02-16","id":438,"title":"Find All Anagrams in a String","difficulty":"medium","topics":["sliding-window","two-pointers","string"],"status":"review","time_min":4,"result":"AC","hints":0,"approach":"Fixed-length window of size |p|; decrement freq when adding, increment when removing; track missing count and record left when zero.","key_insight":"Maintain constant window size and only when freq>=0 decrement missing; freq>0 after increment means window lost needed character.","complexity":"O(n) time, O(1) space (26 letters)."}
{"date":"2026-02-16","id":55,"title":"Jump Game","difficulty":"medium","topics":["greedy","array"],"status":"review","time_min":4,"result":"AC","hints":0,"approach":"Greedily track the farthest reachable index; if at any point i exceeds maxDist we fail, otherwise extend reach to max(maxDist, i+nums[i]).","key_insight":"只需维护最远可达位置，无需实际路径；遍历一次即可判断。","complexity":"O(n) time, O(1) space."}
{"date":"2026-02-17","id":300,"title":"Longest Increasing Subsequence","difficulty":"medium","topics":["dynamic-programming","binary-search"],"status":"review","time_min":9,"result":"AC","hints":0,"approach":"Patience sorting idea: maintain dp list where dp[k] is smallest tail for length k+1; for each num, lower_bound to replace existing tail or append if larger than all tails.","key_insight":"使用 lower_bound 可以在 O(log n) 更新最小结尾值，从而保持 dp 长度为当前 LIS 长度。","notes":"这次主要依靠记忆模板完成，还需再巩固原理。","complexity":"O(n log n) time, O(n) space."}
