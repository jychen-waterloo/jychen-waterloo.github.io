{"date": "2026-02-14", "id": 56, "title": "Merge Intervals", "difficulty": "medium", "topics": ["sorting", "intervals"], "status": "solved", "time_min": 7, "result": "AC", "approach": "Sort intervals then merge into result by extending overlapping end points.", "key_insight": "Sorting by start ensures overlaps appear consecutively so you only compare with the last merged interval.", "mistakes": null, "complexity": "O(n log n) time for sorting, O(1) extra space."}
{"date":"2026-02-14","id":567,"title":"Permutation in String","difficulty":"medium","topics":["sliding-window","frequency-count"],"status":"solved","time_min":22,"result":"AC","approach":"Maintain fixed-length sliding window with char counts; decrement on entering, increment when leaving, track missing chars.","key_insight":"Keep window size equal to |s1| so when missing==0 you have a permutation.","mistakes":"Needed hint to enforce fixed window size; took 3 submissions.","complexity":"O(n) time, O(1) space (26 letters).","notes_path":null}
{"date":"2026-02-15","id":3,"title":"Longest Substring Without Repeating Characters","difficulty":"medium","topics":["sliding-window","hashing"],"status":"solved","time_min":15,"result":"AC","approach":"Use visited array for ASCII chars and move left pointer past duplicates while tracking max window length.","key_insight":"Shrink window only when duplicate reappears; keep window unique via visited flags.","mistakes":"Needed reminder to increment left appropriately when duplicate hit.","complexity":"O(n) time, O(1) space (fixed alphabet).","notes_path":null}
{"date":"2026-02-15","id":560,"title":"Subarray Sum Equals K","difficulty":"medium","topics":["prefix-sum","hashmap"],"status":"solved","time_min":18,"result":"AC","approach":"Track running prefix sum and count how many previous prefixes equal prefix-k; add those counts to result each step.","key_insight":"Prefix differences stay valid even with negatives, unlike sliding windows; seeding map with 0 handles subarrays starting at index 0.","mistakes":"Tried sliding window first and realized it fails when negatives appear.","complexity":"O(n) time, O(n) space for hash map.","notes_path":null}
{"date":"2026-02-15","id":438,"title":"Find All Anagrams in a String","difficulty":"medium","topics":["sliding-window","frequency-count"],"status":"solved","time_min":7,"result":"AC","approach":"Maintain fixed-length sliding window with freq array; decrement when char enters, increment when it leaves, and track missing count.","key_insight":"Keep window size equal to |p| so once missing hits zero you record the left index.","mistakes":null,"complexity":"O(n) time, O(1) space (26 letters).","notes_path":null}
{"date":"2026-02-16","id":76,"title":"Minimum Window Substring","difficulty":"hard","topics":["sliding-window","two-pointers","string"],"status":"review","time_min":20,"result":"AC","hints":1,"approach":"Maintain freq deficits for T; expand right and decrement missing until zero, then shrink left while window still valid, tracking best span.","key_insight":"Left pointer can keep moving while removing surplus chars (freq becomes <=0); stop only when removing makes freq>0 meaning window loses required char.","mistakes":"Uncertain about when to stop shrinking left; needed reminder that freq>0 indicates deficit.","complexity":"O(n) time, O(1) space (fixed alphabet)."}
{"date":"2026-02-16","id":438,"title":"Find All Anagrams in a String","difficulty":"medium","topics":["sliding-window","two-pointers","string"],"status":"review","time_min":4,"result":"AC","hints":0,"approach":"Fixed-length window of size |p|; decrement freq when adding, increment when removing; track missing count and record left when zero.","key_insight":"Maintain constant window size and only when freq>=0 decrement missing; freq>0 after increment means window lost needed character.","complexity":"O(n) time, O(1) space (26 letters)."}
{"date":"2026-02-16","id":55,"title":"Jump Game","difficulty":"medium","topics":["greedy","array"],"status":"review","time_min":4,"result":"AC","hints":0,"approach":"Greedily track the farthest reachable index; if at any point i exceeds maxDist we fail, otherwise extend reach to max(maxDist, i+nums[i]).","key_insight":"只需维护最远可达位置，无需实际路径；遍历一次即可判断。","complexity":"O(n) time, O(1) space."}
{"date":"2026-02-17","id":300,"title":"Longest Increasing Subsequence","difficulty":"medium","topics":["dynamic-programming","binary-search"],"status":"review","time_min":9,"result":"AC","hints":0,"approach":"Patience sorting idea: maintain dp list where dp[k] is smallest tail for length k+1; for each num, lower_bound to replace existing tail or append if larger than all tails.","key_insight":"使用 lower_bound 可以在 O(log n) 更新最小结尾值，从而保持 dp 长度为当前 LIS 长度。","notes":"这次主要依靠记忆模板完成，还需再巩固原理。","complexity":"O(n log n) time, O(n) space."}
{"date":"2026-02-18","id":76,"title":"Minimum Window Substring","difficulty":"hard","topics":["sliding-window","two-pointers","string"],"status":"review","time_min":5,"result":"AC","hints":0,"approach":"Same missing-count sliding window: expand right decreasing freq deficits, then shrink left while window still valid; track best span.","key_insight":"When freq[s[left]] becomes >0 after increment, the window just lost a required char, so stop shrinking and resume expanding.","complexity":"O(n) time, O(1) space (fixed alphabet)."}
{"date":"2026-02-18","id":560,"title":"Subarray Sum Equals K","difficulty":"medium","topics":["prefix-sum","hashmap"],"status":"review","time_min":10,"result":"AC","hints":0,"approach":"Classic prefix sum count: maintain map from prefix sum to frequency, seed with 0, add counts of prefixSum-k each step before incrementing current sum entry.","key_insight":"Seed prefix[0]=1 so subarrays starting at index 0 are counted; negatives don't break the method because prefix differences capture all spans.","notes":"需要在脑子里再巩固为什么要先查再更新，以及为什么 sliding window 不适用于有负数的情况。","complexity":"O(n) time, O(n) space."}
{"date":"2026-02-18","id":416,"title":"Partition Equal Subset Sum","difficulty":"medium","topics":["dynamic-programming","0-1-knapsack"],"status":"new","time_min":12,"result":"AC","hints":1,"approach":"Sum total, return false if odd; otherwise run 0/1 knapsack dp[j]=dp[j]||dp[j-num] for j from target down to num to check if half-sum achievable.","key_insight":"倒序更新一维 dp 防止同一元素被重复使用，本质是 0/1 背包装满容量 target/2。","notes":"初次做主要参考了提示才想到背包模型，需要多次复做巩固。","complexity":"O(n * target) time, O(target) space."}
{"date":"2026-02-19","id":48,"title":"Rotate Image","difficulty":"medium","topics":["array","matrix"],"status":"review","time_min":11,"result":"AC","approach":"Layer-by-layer rotation: shrink top/bottom pointers each pass; within a layer swap four-way using temp.","key_insight":"Treat matrix as concentric squares; swap coordinates (row,col)->(col,n-1-row) four at a time to avoid extra storage.","mistakes":null,"notes":"无提示独立完成，耗时 11 分钟。"}
{"date":"2026-02-19","id":209,"title":"Minimum Size Subarray Sum","difficulty":"medium","topics":["sliding-window","two-pointers"],"status":"review","time_min":8,"result":"AC","hints":0,"approach":"Classic expanding window tracking running sum; shrink left while sum>=target updating best length each pop.","key_insight":"收缩左指针时要先记录窗口长度，再减 nums[left] 并右移 left，避免漏掉最短窗口。","notes":"提交一次过但一开始忘了在 while 循环结束前记录长度；已按模板修正。"}
{"date":"2026-02-19","id":283,"title":"Move Zeroes","difficulty":"medium","topics":["two-pointers","array"],"status":"review","time_min":2.5,"result":"AC","hints":0,"approach":"Two-pointer compaction: scan once, copy non-zero elements forward via write pointer, then fill trailing slots with zero.","key_insight":"先把所有非零按顺序写回前面，再统一补零，避免多余交换。","notes":"2分30秒一遍过，逻辑干净。"}
{"date":"2026-02-19","id":198,"title":"House Robber","difficulty":"medium","topics":["dynamic-programming"],"status":"review","time_min":5,"result":"AC","hints":0,"approach":"Rolling DP: maintain robprev (best including current) and notrobprev (best excluding current); each step robprev = max(notrobprev + nums[i], robprev).","key_insight":"两变量就能表示 rob/skip 状态，更新顺序是先算新 rob，再把旧 rob 赋给 notrobprev。","notes":"5 分钟完成，逻辑顺畅。"}
{"date":"2026-02-19","id":33,"title":"Search in Rotated Sorted Array","difficulty":"medium","topics":["binary-search"],"status":"new","time_min":18,"result":"AC","hints":0,"approach":"Binary search detecting the sorted half each loop: compare nums[st] vs nums[mid], then decide which side to discard.","key_insight":"st<=ed 循环才会遍历到所有候选，更新边界必须用 mid±1，否则会卡死；判断左/右区间是否有序时用 <= 避免重复元素冲突。","notes":"第1次做花18分钟且 WA 多次，主要是边界更新和循环条件搞混，需要再复盘二分套路。"}
{"date":"2026-02-20","id":238,"title":"Product of Array Except Self","difficulty":"medium","topics":["array","prefix-product"],"status":"review","time_min":6,"result":"AC","approach":"Two-pass prefix product: first fill result with left products, then sweep from right multiplying by running rightProduct.","key_insight":"Store left product directly in output, then multiply by accumulated right product to avoid extra arrays.","mistakes":null,"notes":"6分钟独立完成，无卡点，巩固常数空间写法。","complexity":"O(n) time, O(1) extra space."}
{"date":"2026-02-20","id":102,"title":"Binary Tree Level Order Traversal","difficulty":"medium","topics":["tree","bfs"],"status":"review","time_min":7,"result":"AC","approach":"Classic BFS: queue nodes per level, use current queue size to collect each layer before pushing children.","key_insight":"Fix level size upfront so每层处理固定数量节点，无需额外存层号。","mistakes":null,"complexity":"O(n) time, O(n) space for queue."}
{"date":"2026-02-20","id":875,"title":"Koko Eating Bananas","difficulty":"medium","topics":["binary-search","math"],"status":"new","time_min":14,"result":"AC","submissions":2,"mistakes":"第一次把最小速度设成最小堆大小导致答案偏大。","approach":"Binary search on speed k in [1,maxPile]; simulate hours via ceil(pile/k) and shrink boundary when hours <= h.","key_insight":"答案空间具备单调性：速度越快耗时越少，因此用二分找满足条件的最小速度。","complexity":"O(n log maxPile) time, O(1) space."}
