{"date":"2026-02-21","id":34,"title":"Find First and Last Position of Element in Sorted Array","difficulty":"medium","topics":["binary-search"],"status":"review","time_min":15,"result":"AC","submissions":2,"approach":"Two boundary binary searches: lower_bound for first >= target, upper_bound-1 for last occurrence.","key_insight":"Keep both searches on [l, r) and allow returning n so absence is handled cleanly.","mistakes":"Looked up templates mid-way and briefly misused t1>=t2 to detect absence; need more muscle memory.","notes_path":"leetcode/notes/binary_search_bounds.md"}
{"date":"2026-02-21","id":416,"title":"Partition Equal Subset Sum","difficulty":"medium","topics":["dynamic-programming","0-1-knapsack"],"status":"review","time_min":7,"result":"AC","approach":"Classic 0/1 knapsack on target = total/2 with 1D dp; iterate items, then capacity descending to avoid reusing numbers.","key_insight":"Descending capacity ensures each num is used at most once; dp[j] true iff some subset sums to j.","mistakes":"Still fuzzy on the intuition behind the double loop order and what dp[j] represents beyond the template.","notes_path":"leetcode/notes/partition_equal_subset_sum.md"}
{"date":"2026-02-21","id":33,"title":"Search in Rotated Sorted Array","difficulty":"medium","topics":["binary-search"],"status":"review","time_min":6,"result":"AC","submissions":3,"approach":"Standard rotated-array binary search: detect the sorted half (`nums[mid] >= nums[left]`) and keep the side that may contain target.","key_insight":"Treat `[left, mid]` as a closed interval so single-element segments remain \"sorted\"; equality in the check avoids misclassifying intact halves.","mistakes":"Originally wrote `nums[mid] > nums[left]` and forgot why equality matters, so documented the boundary rules.","notes_path":"leetcode/notes/binary_search_boundaries.md"}
{"date":"2026-02-21","id":875,"title":"Koko Eating Bananas","difficulty":"medium","topics":["binary-search","answer-space"],"status":"review","time_min":15,"result":"AC","submissions":1,"approach":"Binary search the rate on a half-open interval `[lo, hi)`; simulate hours with `ceil(pile / mid)` and shrink right when current speed suffices.","key_insight":"Treat the upper bound as an exclusive endpoint so `hi = mid` keeps the invariant intact and returns the first feasible speed.","mistakes":"None today; wrote down the reusable template for future self.","notes_path":"leetcode/notes/koko_eating_bananas_template.cpp"}
{"date":"2026-02-21","id":209,"title":"Minimum Size Subarray Sum","difficulty":"medium","topics":["sliding-window","two-pointers"],"status":"review","time_min":6,"result":"AC","submissions":2,"approach":"Classic expanding window accumulating `sum`, shrink while `sum >= target` to track the minimum length.","key_insight":"Keep `target` untouched and let a separate `sum` govern the shrink condition so the loop reads `while (sum >= target)`.","mistakes":"First submission mutated `target` and effectively required `sum == target`; fixed by restoring the usual template.","notes_path":"leetcode/notes/min_subarray_len.md"}
{"date":"2026-02-21","id":560,"title":"Subarray Sum Equals K","difficulty":"medium","topics":["prefix-sum","hash-map"],"status":"review","time_min":5,"result":"AC","submissions":1,"approach":"Running prefix sum plus hash map of frequencies; count `prefix - k` before recording the current prefix.","key_insight":"The order (query first, then increment) prevents double-counting and ensures subarrays starting at index 0 are handled via `map[0] = 1`.","mistakes":"None today; reinforced the count-before-update rule.","notes_path":"leetcode/notes/prefix_sum_hashmap.md"}
{"date":"2026-02-21","id":76,"title":"Minimum Window Substring","difficulty":"hard","topics":["sliding-window","two-pointers"],"status":"review","time_min":5,"result":"AC","submissions":1,"approach":"Two pointers with frequency map: expand right until all needs satisfied, then shrink left while updating best window.","key_insight":"Use `missing == 0` as the shrink trigger and only break when removing a required char pushes its count above zero again.","mistakes":"None on this run; documented the shrink condition to keep it automatic.","notes_path":"leetcode/notes/min_window_substring.md"}
{"date":"2026-02-21","id":213,"title":"House Robber II","difficulty":"medium","topics":["dynamic-programming"],"status":"learning","time_min":18,"result":"AC","submissions":1,"approach":"Evaluate two linear robber runs: houses `[0, n-2]` and `[1, n-1]`, each with rolling `take/skip` states, then return the max.","key_insight":"Splitting the circle removes the adjacency conflict; reusing the House Robber I DP keeps the implementation simple.","mistakes":"None, but noted that interleaving the two cases in one loop is harder to read than separate helpers.","notes_path":"leetcode/notes/house_robber_ii.md"}
{"date":"2026-02-22","id":875,"title":"Koko Eating Bananas","difficulty":"medium","topics":["binary-search","answer-space"],"status":"review","time_min":6,"result":"AC","submissions":1,"approach":"Binary search speed on [1, maxPile], compute required hours by ceiling division per pile, tighten right bound when feasible.","key_insight":"Use lower-bound style search for the first feasible speed: if totalHours(mid) <= h, keep mid by setting hi = mid.","mistakes":"None; one-pass AC with clean invariants.","notes_path":"leetcode/notes/koko_eating_bananas_template.cpp"}
{"date":"2026-02-22","id":34,"title":"Find First and Last Position of Element in Sorted Array","difficulty":"medium","topics":["binary-search"],"status":"learning","time_min":23,"result":"AC","submissions":4,"approach":"Use two half-open binary searches: lower bound for first >= target and upper bound for first > target, then right = upper-1.","key_insight":"Keep both searches on [l,r) with r=n to avoid dead loops; always validate index before dereferencing.","mistakes":"Mixed closed and half-open interval templates at first; had out-of-bounds risk in lower and wrong right-bound handling in upper.","notes_path":"leetcode/notes/binary_search_bounds.md"}
{"date":"2026-02-22","id":416,"title":"Partition Equal Subset Sum","difficulty":"medium","topics":["dynamic-programming","0-1-knapsack"],"status":"learning","time_min":6,"result":"AC","submissions":2,"approach":"1D 0/1 knapsack on target=total/2; for each num, iterate j from target down to num with dp[j] |= dp[j-num].","key_insight":"Descending j is mandatory to prevent reusing the same number in one round.","mistakes":"First attempt had wrong dp transition update; fixed by restoring dp[j] = dp[j] || dp[j-num].","notes_path":"leetcode/notes/partition_equal_subset_sum.md"}
{"date":"2026-02-22","id":213,"title":"House Robber II","difficulty":"medium","topics":["dynamic-programming"],"status":"review","time_min":6,"result":"AC","submissions":1,"approach":"Split circular houses into two linear ranges [0,n-2] and [1,n-1], solve each with rolling rob/skip states and take max.","key_insight":"Circular adjacency is removed by evaluating two linear cases; each case uses House Robber I transition cur=max(skip+nums[i], rob).","mistakes":"None; implementation concise and stable.","notes_path":"leetcode/notes/house_robber_ii.md"}
{"date":"2026-02-22","id":560,"title":"Subarray Sum Equals K","difficulty":"medium","topics":["prefix-sum","hash-map"],"status":"review","time_min":5,"result":"AC","submissions":1,"approach":"Maintain running prefix sum and a frequency map; for each position add count[prefix-k], then increment count[prefix].","key_insight":"Order matters: query count[prefix-k] before count[prefix]++ to avoid counting current index as a prior prefix.","mistakes":"None; one-pass implementation was correct.","notes_path":"leetcode/notes/prefix_sum_hashmap.md"}
{"date":"2026-02-24","id":81,"title":"Search in Rotated Sorted Array II","difficulty":"medium","topics":["binary-search"],"status":"learning","time_min":12,"result":"AC","submissions":2,"hints":1,"approach":"Binary search with duplicate handling: if nums[left]==nums[mid]==nums[right], shrink both ends; otherwise decide sorted half and keep the side containing target.","key_insight":"When triple-equal occurs, sorted-half inference is ambiguous, so deduplicate boundaries first before reusing rotated-array logic.","mistakes":"Initially got stuck on cases like [1,0,1,1,1,1] and needed reminder to shrink on triple-equal.","notes_path":"leetcode/notes/binary_search_boundaries.md"}
{"date":"2026-02-24","id":494,"title":"Target Sum","difficulty":"medium","topics":["dynamic-programming","0-1-knapsack"],"status":"learning","time_min":16,"result":"AC","submissions":2,"hints":1,"approach":"Transform sign assignment into subset-sum counting: choose subset S1 with sum=(total+target)/2, then count ways via 1D 0/1 knapsack DP.","key_insight":"Feasibility checks come first: total+target must be non-negative and even.","mistakes":"First wrong submission missed the guard total+target>=0.","notes_path":"leetcode/notes/partition_equal_subset_sum.md"}
{"date":"2026-02-24","id":162,"title":"Find Peak Element","difficulty":"medium","topics":["binary-search"],"status":"learning","time_min":10,"result":"AC","submissions":1,"approach":"Binary search on slope: compare nums[mid] and nums[mid+1]; move toward the side that must contain a peak until l==r.","key_insight":"You only need any peak, and slope direction gives a half-interval guarantee each step.","mistakes":"No WA; clarified why final left remains a peak.","notes_path":"leetcode/notes/binary_search_boundaries.md"}
{"date":"2026-02-24","id":300,"title":"Longest Increasing Subsequence","difficulty":"medium","topics":["dynamic-programming","binary-search"],"status":"learning","time_min":10,"result":"AC","submissions":1,"approach":"Patience sorting style dp of minimal tails; for each num, lower_bound first >= num and replace/append.","key_insight":"dp[len-1] stores the minimum possible tail for subsequence length len; replacing tails keeps future options maximal.","mistakes":"Minor hesitation on lower_bound boundary details.","notes_path":"leetcode/notes/LIS_derivation.md"}
{"date":"2026-02-24","id":2517,"title":"Maximum Tastiness of Candy Basket","difficulty":"medium","topics":["binary-search","greedy","answer-space"],"status":"learning","time_min":20,"result":"AC","submissions":2,"approach":"Sort first, then binary search answer d; greedy can(d) picks earliest feasible next element with gap >= d until k chosen.","key_insight":"Feasibility is monotonic in d, so maximize feasible d with upper-bound binary search.","mistakes":"Binary-search boundary handling caused one wrong submission before settling max-feasible template.","notes_path":"leetcode/notes/koko_eating_bananas_template.cpp"}
{"date":"2026-02-25","id":34,"title":"Find First and Last Position of Element in Sorted Array","difficulty":"medium","topics":["binary-search"],"status":"review","time_min":11,"result":"AC","submissions":2,"approach":"Two binary searches on half-open range [l,r): lower bound for first >= target and upper bound for first > target, then right=upper-1.","key_insight":"For upper bound, keep a single invariant (first > target) instead of mixing result tracking and boundary checks.","mistakes":"Upper bound implementation felt awkward; mixed answer sources before consolidating to canonical template.","notes_path":"leetcode/notes/binary_search_bounds.md"}
{"date":"2026-02-25","id":81,"title":"Search in Rotated Sorted Array II","difficulty":"medium","topics":["binary-search"],"status":"review","time_min":5,"result":"AC","submissions":1,"approach":"Binary search with duplicate handling: if nums[left]==nums[mid]==nums[right], shrink both ends; otherwise keep the sorted half that can contain target.","key_insight":"When triple-equal appears, deduplicate boundaries first, then reuse rotated-array half-selection logic safely.","mistakes":"None.","notes_path":"leetcode/notes/binary_search_boundaries.md"}
{"date":"2026-02-25","id":494,"title":"Target Sum","difficulty":"medium","topics":["dynamic-programming","0-1-knapsack"],"status":"review","time_min":7,"result":"AC","submissions":2,"approach":"Transform to subset-sum counting with S1=(total+target)/2 and run 1D 0/1 knapsack counting ways.","key_insight":"Always run feasibility checks before DP: abs(target)<=total, total+target>=0, and parity even.","mistakes":"Missed the total+target>=0 guard again on first attempt.","notes_path":"leetcode/notes/partition_equal_subset_sum.md"}
{"date":"2026-02-25","id":560,"title":"Subarray Sum Equals K","difficulty":"medium","topics":["prefix-sum","hash-map"],"status":"review","time_min":12,"result":"AC","submissions":1,"approach":"Prefix-sum with frequency map: add count[prefix-k] before incrementing count[prefix].","key_insight":"The query-before-update order is mandatory to avoid counting current prefix as previous.","mistakes":"Brief recall gap mid-solve, then recovered template correctly.","notes_path":"leetcode/notes/prefix_sum_hashmap.md"}
{"date":"2026-02-27","id":153,"title":"Find Minimum in Rotated Sorted Array","difficulty":"medium","topics":["binary-search"],"status":"review","time_min":12,"result":"AC","submissions":1,"hints":1,"approach":"Binary search on rotated array: if current window is already sorted (nums[left] < nums[right]), nums[left] is min; otherwise compare nums[mid] with nums[right] to choose side.","key_insight":"nums[mid] > nums[right] means min is strictly on the right; else min is at mid or left side, so keep mid with right = mid.","mistakes":"None in final code; used one hint before implementation.","notes_path":"leetcode/notes/binary_search_boundaries.md"}
{"date":"2026-02-27","id":2300,"title":"Successful Pairs of Spells and Potions","difficulty":"medium","topics":["binary-search","sorting"],"status":"review","time_min":12,"result":"AC","submissions":1,"approach":"Sort potions once, then for each spell binary search first potion index where spell*potions[idx] >= success; count is m-idx.","key_insight":"Lower-bound on threshold keeps complexity at O(m log m + n log m) without sorting spells.","mistakes":"No correctness issues; only concern was perceived runtime speed.","notes_path":"leetcode/notes/binary_search_bounds.md"}
{"date":"2026-02-27","id":1049,"title":"Last Stone Weight II","difficulty":"medium","topics":["dynamic-programming","0-1-knapsack"],"status":"learning","time_min":15,"result":"AC","submissions":1,"hints":1,"approach":"Convert to partition problem: maximize reachable subset sum <= total/2 using 1D 0-1 knapsack boolean DP, then answer is total-2*best.","key_insight":"Backward iteration on capacity is required so each stone is used at most once.","mistakes":"Initial confusion on alternate Â±sum DP hint; solved after reframing as partition knapsack.","notes_path":"leetcode/notes/knapsack_0-1.md"}
{"date":"2026-02-28","id":74,"title":"Search a 2D Matrix","difficulty":"medium","topics":["binary-search","matrix"],"status":"review","time_min":15,"result":"AC","submissions":2,"approach":"Two-stage binary search: upper_bound on first column to choose candidate row, then classic binary search inside that row.","key_insight":"Treat row search as half-open interval [0,m) and step back one row after upper_bound to avoid off-by-one errors.","mistakes":"Mid-solve switched to upper-bound framing; final logic was correct but felt a bit verbose.","notes_path":"leetcode/notes/binary_search_boundaries.md"}
{"date":"2026-02-28","id":322,"title":"Coin Change","difficulty":"medium","topics":["dynamic-programming","unbounded-knapsack"],"status":"review","time_min":4,"result":"AC","submissions":1,"approach":"1D complete knapsack DP where dp[i] stores minimum coins for amount i; iterate coins then i from coin..amount.","key_insight":"Forward capacity iteration enables reusing the same coin multiple times, matching unbounded usage.","mistakes":"None.","notes_path":"leetcode/notes/partition_equal_subset_sum.md"}
{"date":"2026-02-28","id":207,"title":"Course Schedule","difficulty":"medium","topics":["graph","topological-sort","bfs"],"status":"review","time_min":7,"result":"AC","submissions":1,"approach":"Kahn topological sort with indegree array and queue of zero-indegree nodes; consume edges until queue empties.","key_insight":"Tracking remaining edge count (or processed node count) gives a direct acyclic check at the end.","mistakes":"None.","notes_path":"leetcode/notes/house_robber_ii.md"}
{"date":"2026-03-01","id":875,"title":"Koko Eating Bananas","difficulty":"medium","topics":["binary-search","answer-space"],"status":"review","time_min":4,"result":"AC","submissions":1,"approach":"Binary search minimum feasible eating speed and compute required hours via ceiling division for each pile.","key_insight":"Keep lower-bound invariant: when hours(mid) <= h, preserve mid by moving hi = mid.","mistakes":"None.","notes_path":"leetcode/notes/koko_eating_bananas_template.cpp"}
{"date":"2026-03-01","id":81,"title":"Search in Rotated Sorted Array II","difficulty":"medium","topics":["binary-search"],"status":"review","time_min":4,"result":"AC","submissions":2,"approach":"Binary search with duplicate handling; shrink both ends when left==mid==right, otherwise keep the sorted half that may contain target.","key_insight":"Deduplicate ambiguous boundaries first, then apply rotated-array half selection safely.","mistakes":"One incorrect boundary branch before final AC.","notes_path":"leetcode/notes/binary_search_boundaries.md"}
{"date":"2026-03-01","id":494,"title":"Target Sum","difficulty":"medium","topics":["dynamic-programming","0-1-knapsack"],"status":"review","time_min":8,"result":"AC","submissions":1,"approach":"Transform to subset-sum count with S1=(total+target)/2 and run 1D 0/1 knapsack counting ways.","key_insight":"Feasibility checks first: total+target must be non-negative and even.","mistakes":"None.","notes_path":"leetcode/notes/partition_equal_subset_sum.md"}
{"date":"2026-03-01","id":210,"title":"Course Schedule II","difficulty":"medium","topics":["graph","topological-sort","bfs"],"status":"learning","time_min":7,"result":"AC","submissions":1,"approach":"Use Kahn topological sort (indegree + queue) to build a valid course order.","key_insight":"Only when output size equals numCourses is the schedule acyclic and valid.","mistakes":"None.","notes_path":"leetcode/notes/house_robber_ii.md"}
