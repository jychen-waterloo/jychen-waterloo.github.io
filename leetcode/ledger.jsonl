{"date":"2026-02-21","id":34,"title":"Find First and Last Position of Element in Sorted Array","difficulty":"medium","topics":["binary-search"],"status":"review","time_min":15,"result":"AC","submissions":2,"approach":"Two boundary binary searches: lower_bound for first >= target, upper_bound-1 for last occurrence.","key_insight":"Keep both searches on [l, r) and allow returning n so absence is handled cleanly.","mistakes":"Looked up templates mid-way and briefly misused t1>=t2 to detect absence; need more muscle memory.","notes_path":"leetcode/notes/binary_search_bounds.md"}
{"date":"2026-02-21","id":416,"title":"Partition Equal Subset Sum","difficulty":"medium","topics":["dynamic-programming","0-1-knapsack"],"status":"review","time_min":7,"result":"AC","approach":"Classic 0/1 knapsack on target = total/2 with 1D dp; iterate items, then capacity descending to avoid reusing numbers.","key_insight":"Descending capacity ensures each num is used at most once; dp[j] true iff some subset sums to j.","mistakes":"Still fuzzy on the intuition behind the double loop order and what dp[j] represents beyond the template.","notes_path":"leetcode/notes/partition_equal_subset_sum.md"}
{"date":"2026-02-21","id":33,"title":"Search in Rotated Sorted Array","difficulty":"medium","topics":["binary-search"],"status":"review","time_min":6,"result":"AC","submissions":3,"approach":"Standard rotated-array binary search: detect the sorted half (`nums[mid] >= nums[left]`) and keep the side that may contain target.","key_insight":"Treat `[left, mid]` as a closed interval so single-element segments remain \"sorted\"; equality in the check avoids misclassifying intact halves.","mistakes":"Originally wrote `nums[mid] > nums[left]` and forgot why equality matters, so documented the boundary rules.","notes_path":"leetcode/notes/binary_search_boundaries.md"}
{"date":"2026-02-21","id":875,"title":"Koko Eating Bananas","difficulty":"medium","topics":["binary-search","answer-space"],"status":"review","time_min":15,"result":"AC","submissions":1,"approach":"Binary search the rate on a half-open interval `[lo, hi)`; simulate hours with `ceil(pile / mid)` and shrink right when current speed suffices.","key_insight":"Treat the upper bound as an exclusive endpoint so `hi = mid` keeps the invariant intact and returns the first feasible speed.","mistakes":"None today; wrote down the reusable template for future self.","notes_path":"leetcode/notes/koko_eating_bananas_template.cpp"}
{"date":"2026-02-21","id":209,"title":"Minimum Size Subarray Sum","difficulty":"medium","topics":["sliding-window","two-pointers"],"status":"review","time_min":6,"result":"AC","submissions":2,"approach":"Classic expanding window accumulating `sum`, shrink while `sum >= target` to track the minimum length.","key_insight":"Keep `target` untouched and let a separate `sum` govern the shrink condition so the loop reads `while (sum >= target)`.","mistakes":"First submission mutated `target` and effectively required `sum == target`; fixed by restoring the usual template.","notes_path":"leetcode/notes/min_subarray_len.md"}
{"date":"2026-02-21","id":560,"title":"Subarray Sum Equals K","difficulty":"medium","topics":["prefix-sum","hash-map"],"status":"review","time_min":5,"result":"AC","submissions":1,"approach":"Running prefix sum plus hash map of frequencies; count `prefix - k` before recording the current prefix.","key_insight":"The order (query first, then increment) prevents double-counting and ensures subarrays starting at index 0 are handled via `map[0] = 1`.","mistakes":"None today; reinforced the count-before-update rule.","notes_path":"leetcode/notes/prefix_sum_hashmap.md"}
{"date":"2026-02-21","id":76,"title":"Minimum Window Substring","difficulty":"hard","topics":["sliding-window","two-pointers"],"status":"review","time_min":5,"result":"AC","submissions":1,"approach":"Two pointers with frequency map: expand right until all needs satisfied, then shrink left while updating best window.","key_insight":"Use `missing == 0` as the shrink trigger and only break when removing a required char pushes its count above zero again.","mistakes":"None on this run; documented the shrink condition to keep it automatic.","notes_path":"leetcode/notes/min_window_substring.md"}
{"date":"2026-02-21","id":213,"title":"House Robber II","difficulty":"medium","topics":["dynamic-programming"],"status":"learning","time_min":18,"result":"AC","submissions":1,"approach":"Evaluate two linear robber runs: houses `[0, n-2]` and `[1, n-1]`, each with rolling `take/skip` states, then return the max.","key_insight":"Splitting the circle removes the adjacency conflict; reusing the House Robber I DP keeps the implementation simple.","mistakes":"None, but noted that interleaving the two cases in one loop is harder to read than separate helpers.","notes_path":"leetcode/notes/house_robber_ii.md"}
{"date":"2026-02-22","id":875,"title":"Koko Eating Bananas","difficulty":"medium","topics":["binary-search","answer-space"],"status":"review","time_min":6,"result":"AC","submissions":1,"approach":"Binary search speed on [1, maxPile], compute required hours by ceiling division per pile, tighten right bound when feasible.","key_insight":"Use lower-bound style search for the first feasible speed: if totalHours(mid) <= h, keep mid by setting hi = mid.","mistakes":"None; one-pass AC with clean invariants.","notes_path":"leetcode/notes/koko_eating_bananas_template.cpp"}
{"date":"2026-02-22","id":34,"title":"Find First and Last Position of Element in Sorted Array","difficulty":"medium","topics":["binary-search"],"status":"learning","time_min":23,"result":"AC","submissions":4,"approach":"Use two half-open binary searches: lower bound for first >= target and upper bound for first > target, then right = upper-1.","key_insight":"Keep both searches on [l,r) with r=n to avoid dead loops; always validate index before dereferencing.","mistakes":"Mixed closed and half-open interval templates at first; had out-of-bounds risk in lower and wrong right-bound handling in upper.","notes_path":"leetcode/notes/binary_search_bounds.md"}
{"date":"2026-02-22","id":416,"title":"Partition Equal Subset Sum","difficulty":"medium","topics":["dynamic-programming","0-1-knapsack"],"status":"learning","time_min":6,"result":"AC","submissions":2,"approach":"1D 0/1 knapsack on target=total/2; for each num, iterate j from target down to num with dp[j] |= dp[j-num].","key_insight":"Descending j is mandatory to prevent reusing the same number in one round.","mistakes":"First attempt had wrong dp transition update; fixed by restoring dp[j] = dp[j] || dp[j-num].","notes_path":"leetcode/notes/partition_equal_subset_sum.md"}
{"date":"2026-02-22","id":213,"title":"House Robber II","difficulty":"medium","topics":["dynamic-programming"],"status":"review","time_min":6,"result":"AC","submissions":1,"approach":"Split circular houses into two linear ranges [0,n-2] and [1,n-1], solve each with rolling rob/skip states and take max.","key_insight":"Circular adjacency is removed by evaluating two linear cases; each case uses House Robber I transition cur=max(skip+nums[i], rob).","mistakes":"None; implementation concise and stable.","notes_path":"leetcode/notes/house_robber_ii.md"}
{"date":"2026-02-22","id":560,"title":"Subarray Sum Equals K","difficulty":"medium","topics":["prefix-sum","hash-map"],"status":"review","time_min":5,"result":"AC","submissions":1,"approach":"Maintain running prefix sum and a frequency map; for each position add count[prefix-k], then increment count[prefix].","key_insight":"Order matters: query count[prefix-k] before count[prefix]++ to avoid counting current index as a prior prefix.","mistakes":"None; one-pass implementation was correct.","notes_path":"leetcode/notes/prefix_sum_hashmap.md"}
{"date":"2026-02-24","id":81,"title":"Search in Rotated Sorted Array II","difficulty":"medium","topics":["binary-search"],"status":"learning","time_min":12,"result":"AC","submissions":2,"hints":1,"approach":"Binary search with duplicate handling: if nums[left]==nums[mid]==nums[right], shrink both ends; otherwise decide sorted half and keep the side containing target.","key_insight":"When triple-equal occurs, sorted-half inference is ambiguous, so deduplicate boundaries first before reusing rotated-array logic.","mistakes":"Initially got stuck on cases like [1,0,1,1,1,1] and needed reminder to shrink on triple-equal.","notes_path":"leetcode/notes/binary_search_boundaries.md"}
{"date":"2026-02-24","id":494,"title":"Target Sum","difficulty":"medium","topics":["dynamic-programming","0-1-knapsack"],"status":"learning","time_min":16,"result":"AC","submissions":2,"hints":1,"approach":"Transform sign assignment into subset-sum counting: choose subset S1 with sum=(total+target)/2, then count ways via 1D 0/1 knapsack DP.","key_insight":"Feasibility checks come first: total+target must be non-negative and even.","mistakes":"First wrong submission missed the guard total+target>=0.","notes_path":"leetcode/notes/partition_equal_subset_sum.md"}
